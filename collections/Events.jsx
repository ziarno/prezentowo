import {LoggedIn} from '../lib/Mixins'/** * Events Collection */Events = new Mongo.Collection('events')Events.permit(['insert', 'update', 'remove']).never().apply() //ongoworks:security/** * SCHEMAS */Events.Schemas = {}Events.Schemas.NewParticipant = new SimpleSchema({  _id: {    type: String,    regEx: SimpleSchema.RegEx.Id,    optional: true  },  name: {    type: String,    label: () => _i18n.__('Fullname')  },  email: {    type: String,    optional: true,    custom: function () {      //only check regex if value is not empty      if (this.value && !          SimpleSchema.RegEx.Email.test(this.value)) {        return 'invalidEmail'      }    }  },  pictureUrl: {    type: SimpleSchema.RegEx.Url,    label: () => _i18n.__('Picture')  },  gender: {    type: String,    allowedValues: ['male', 'female'],    label: () => _i18n.__('Gender')  }})Events.Schemas.Participant = new SimpleSchema({  userId: {    type: String,    regEx: SimpleSchema.RegEx.Id  },  invitation: {    type: Object,    optional: true  },  'invitation.id': {    type: String,    regEx: SimpleSchema.RegEx.Id,    optional: true  },  'invitation.status': {    type: String,    allowedValues: ['accepted', 'pending', 'rejected'],    defaultValue: 'pending'  }})Events.Schemas.Main = new SimpleSchema({  title: {    type: String,    max: 55,    label: () => _i18n.__('Title')  },  type: {    type: String,    label: () => _i18n.__('Event Type'),    allowedValues: ['many-to-many', 'many-to-one']  },  date: {    type: Date,    label: () => _i18n.__('Date'),    min: () => new Date()  },  createdAt: {    type: Date,    label: () => _i18n.__('Created'),    autoValue() {      if (this.isInsert) {        return new Date()      }    }  },  creatorId: {    type: String,    regEx: SimpleSchema.RegEx.Id,    label: () => _i18n.__('Creator'),    autoValue() {      if (this.isSet) {        return this.value      }      if (this.isInsert) {        return this.userId      }    }  },  beneficiaryIds: {    type: [String],    regEx: SimpleSchema.RegEx.Id,    optional: true  },  participants: {    type: [Events.Schemas.Participant],    label: () => _i18n.__('Participants'),    defaultValue: []  }})Events.attachSchema(Events.Schemas.Main)/** * HELPER FUNCTIONS */Events.functions = {}Events.functions.addParticipant = function ({eventId, participant}) {  Events.Schemas.Participant.clean(participant) //clean explicitly, because bug in collection2 for autoValue and defaultValue - this.field('field') doesn't return correct field in sub schemas. Note: use Events.Schemas.Participant (not NewParticipant) so basically convert from NewParticipant to Participant  return Events.update(eventId, {$push: {participants: participant}})}Events.functions.isUserParticipant = function ({eventId, participantId}) {  return !!Events.findOne({    _id: eventId,    participants: {      $elemMatch: {        userId: participantId      }    }  })}Events.functions.setInvitationStatus = function ({eventId, participantId, status}) {  return Events.update({    _id: eventId,    'participants.userId': participantId  }, {    $set: {      'participants.$.invitation.status': status    }  })}Events.functions.setBeneficiary = function ({eventId, participantId}, action) {  var modificator = action ? '$addToSet' : '$pull'  //security checks  Events.functions    .check({eventId})    .eventExists()    .isEventCreator(this.userId)    .isParticipant(participantId)  return Events.update({    _id: eventId,    creatorId: this.userId  }, {    [modificator]: {      beneficiaryIds: participantId    }  })}Events.functions.check = function ({eventId, event}) {  var event = event || (eventId && Events.findOne(eventId))  function isParticipant(userId) {    return !!_.find(event.participants, (p) => p.userId === userId)  }  return {    eventExists() {      if (!event) {        throw new Meteor.Error('eventNotFound', _i18n.__('No event', {eventId}))      }      return this    },    isEventCreator(userId) {      if (userId !== event.creatorId) {        throw new Meteor.Error('unauthorized', _i18n.__('Not event creator', {eventId}))      }      return this    },    isNotEventCreator(userId) {      if (userId === event.creatorId) {        throw new Meteor.Error(`${this.name}.creatorCannotBeRemoved`, _i18n.__('Remove creator'))      }      return this    },    isNotParticipant(userId) {      if (isParticipant(userId)) {        throw new Meteor.Error(`${this.name}.alreadyParticipant`, _i18n.__('This user is already a participant', {eventId}))      }      return this    },    isParticipant(userId) {      if (!isParticipant(userId)) {        throw new Meteor.Error(`${this.name}.unauthorized`)      }    }  }}/** * METHODS */Events.methods = {}Events.methods.createEvent = new ValidatedMethod({  name: 'Events.methods.createEvent',  mixins: [LoggedIn],  validate: Events.Schemas.Main    .pick(['title', 'type', 'date'])    .validator(),  run(eventData) {    var eventId    eventId = Events.insert(eventData)    Events.functions.addParticipant({      eventId,      participant: {        userId: this.userId,        invitation: {          status: 'accepted'        }      }    })    return eventId  }})Events.methods.editEvent = new ValidatedMethod({  name: 'Events.methods.editEvent',  mixins: [LoggedIn],  validate: new SimpleSchema([    {      eventId: {        type: String,        regEx: SimpleSchema.RegEx.Id      }    },    Events.Schemas.Main.pick(['title', 'type', 'date'])  ]).validator(),  run({eventId, title, type, date}) {    return Events.update({      _id: eventId,      creatorId: this.userId    }, {      $set: {        title,        type,        date      }    })  }})Events.methods.removeEvent = new ValidatedMethod({  name: 'Events.methods.removeEvent',  mixins: [LoggedIn],  validate: new SimpleSchema({      eventId: {        type: String,        regEx: SimpleSchema.RegEx.Id      }    }).validator(),  run({eventId}) {    var event = Events.findOne(eventId)    var presents = Presents.find({eventId}).fetch()    var commentIds = _.flatten(      presents.map(p => [...p.commentsSecret, ...p.commentsShared])    )    var participantIds = event && event.participants.map(p => p.userId)    //security checks    Events.functions      .check({event})      .eventExists()      .isEventCreator(this.userId)    Events.remove(eventId)    Presents.remove({eventId})    Users.functions.removeTempUsers({_id: {$in: participantIds}})    Comments.remove({_id: {$in: commentIds}})    Invitations.remove({forEventId: eventId})    Notifications.remove({'forEvent.id': eventId})  }})Events.methods.addParticipant = new ValidatedMethod({  name: 'Events.methods.addParticipant',  mixins: [LoggedIn],  validate: new SimpleSchema({    eventId: {      type: String    },    sendEmail: {      type: Boolean    },    participant: {      type: Events.Schemas.NewParticipant    }  }).validator(),  run({eventId, participant}) {    if (this.isSimulation) {      //Note: no latency compensation. Add in the future?      return    }    var user = Users.functions.findByEmail(participant.email)    var invitationId    var isTemp = false    //security checks    Events.functions      .check({eventId})      .eventExists()      .isEventCreator(this.userId)      .isNotParticipant(participant._id)    //user check    if (user) {      //if user's email exists, just use his id      participant.userId = user._id    } else {      //if not, create a new TEMPORARY user      isTemp = true      participant.userId = Users.functions.createTemp(participant)    }    //create invitation    invitationId = Invitations.insert({      forEventId: eventId,      forUserId: participant.userId,      isForTempUser: isTemp    })    participant.invitation = {      id: invitationId,      status: 'pending'    }    Events.functions.addParticipant({eventId, participant})    return participant  }})Events.methods.editParticipant = new ValidatedMethod({  name: 'Events.methods.editParticipant',  mixins: [LoggedIn],  validate: new SimpleSchema({    eventId: {      type: String    },    participant: {      type: Events.Schemas.NewParticipant    }  }).validator(),  run({eventId, participant}) {    //security checks    Events.functions      .check({eventId})      .eventExists()      .isEventCreator(this.userId)      .isParticipant(participant._id)    return Users.functions.update({      _id: participant._id,      isTemp: true    }, participant)  }})Events.methods.removeParticipant = new ValidatedMethod({  name: 'Events.methods.removeParticipant',  mixins: [LoggedIn],  validate: new SimpleSchema({    eventId: {      type: String    },    participantId: {      type: String    }  }).validator(),  run({eventId, participantId}) {    //security checks    Events.functions      .check({eventId})      .eventExists()      .isEventCreator(this.userId)      .isNotEventCreator(participantId)      .isParticipant(participantId)    Events.update({      _id: eventId,      creatorId: this.userId    }, {      $pull: {        participants: {          userId: participantId        }      }    })    Invitations.remove({      forEventId: eventId,      forUserId: participantId    })    Users.functions.removeTempUsers({      _id: participantId    })    Presents.remove({      forUserId: participantId    })  }})Events.methods.addBenficiary = new ValidatedMethod({  name: 'Events.methods.addBenficiary',  mixins: [LoggedIn],  validate: new SimpleSchema({    eventId: {      type: String    },    participantId: {      type: String    }  }).validator(),  run(data) {    return Events.functions.setBeneficiary.call(this, data, true)  }})Events.methods.removeBenficiary = new ValidatedMethod({  name: 'Events.methods.removeBenficiary',  mixins: [LoggedIn],  validate: new SimpleSchema({    eventId: {      type: String    },    participantId: {      type: String    }  }).validator(),  run(data) {    return Events.functions.setBeneficiary.call(this, data, false)  }})